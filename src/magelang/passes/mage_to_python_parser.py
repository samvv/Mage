
import functools
from magelang.helpers import get_field_name, make_py_cond, make_py_union, to_py_class_name
from magelang.lang.mage.ast import *
from magelang.lang.python.cst import *
from magelang.logging import warn
from magelang.util import NameGenerator, unreachable

# FIXME every expr may only peek or fork so that when there is an error, the stream can correctly be skipped
# def ; def foo(): bar <- if ';' is consumed during parsing error we skip too many tokens

type AcceptFn = Callable[[], Generator[PyStmt]]
type RejectFn = Callable[[], Generator[PyStmt]]

def mage_to_python_parser(grammar: MageGrammar, prefix: str) -> PyModule:

    stmts = list[PyStmt]()

    stmts.append(PyImportFromStmt(
        PyAbsolutePath(PyQualName(modules=[ 'magelang' ], name='runtime')),
        [ PyFromAlias('BaseParser'), PyFromAlias('Punctuated') ]
    ))

    def get_parse_method_name(rule: MageRule) -> str:
         return f'parse_{rule.name}'

    def gen_parse_body(rule: MageRule) -> list[PyStmt]:

        generate_name = NameGenerator()
        generate_name('stream') # Mark function parameter as being in use

        fields = list[str]()

        def next_break() -> Generator[PyStmt]:
            yield PyBreakStmt()

        def next_return_error() -> Generator[PyStmt]:
            yield PyRetStmt()

        def next_noop() -> Generator[PyStmt]:
            return
            yield

        def visit_prim_field_inner(expr: MageExpr, stream_name: str, target_name: str, accept: AcceptFn, reject: RejectFn, invert: bool) -> Generator[PyStmt]:
            """
            Generate parse logic for a single expression.

            It is assumed that the code generated by `accept` and `reject` eventually terminates control flow, either by returning of by throwing an exception.
            """

            if isinstance(expr, MageLitExpr):
                unreachable()

            elif isinstance(expr, MageCharSetExpr):
                unreachable()

            elif isinstance(expr, MageSeqExpr):
                unreachable()

            elif isinstance(expr, MageRefExpr):

                assert(expr.symbol is not None)

                rule = cast(MageRule, expr.symbol.definition)

                if rule.expr is None:
                    yield from accept()
                    return # TODO figure out what to yield

                elif not rule.is_public:
                    yield from visit_field_inner(rule.expr, stream_name, target_name, accept, reject, invert)

                elif grammar.is_parse_rule(rule):
                    method_name = get_parse_method_name(rule)
                    yield PyAssignStmt(PyNamedPattern(target_name), value=PyCallExpr(PyAttrExpr(PyNamedExpr('self'), method_name), args=[ PyNamedExpr(stream_name) ]))
                    if invert:
                        yield from make_py_cond([
                            (PyInfixExpr(PyNamedExpr(target_name), (PyIsKeyword(), PyNotKeyword()), PyNamedExpr('None')), list(accept())),
                            (None, list(reject())),
                        ])
                    else:
                        yield from make_py_cond([
                            (PyInfixExpr(PyNamedExpr(target_name), PyIsKeyword(), PyNamedExpr('None')), list(reject())),
                            (None, list(accept())),
                        ])

                elif grammar.is_token_rule(rule):
                    yield PyAssignStmt(PyNamedPattern(target_name), value=PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'get')))
                    if invert:
                        yield from make_py_cond([
                            (PyCallExpr(PyNamedExpr('isinstance'), args=[ PyNamedExpr(target_name), PyNamedExpr(to_py_class_name(rule.name, prefix=prefix)) ]), list(accept())),
                            (None, list(reject())),
                        ])
                    else:
                        yield from make_py_cond([
                            (PyPrefixExpr(PyNotKeyword(), PyCallExpr(PyNamedExpr('isinstance'), args=[ PyNamedExpr(target_name), PyNamedExpr(to_py_class_name(rule.name, prefix=prefix)) ])), list(reject())),
                            (None, list(accept())),
                        ])

                else:
                    unreachable()

            elif isinstance(expr, MageChoiceExpr):

                n = len(expr.elements)

                def loop(i: int) -> Generator[PyStmt]:
                    if i == n:
                        yield from reject()
                    else:
                        element = expr.elements[i]
                        new_stream_name = generate_name('stream')
                        def c_join_accept() -> Generator[PyStmt]:
                            yield PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'join_to'), args=[ PyNamedExpr(new_stream_name) ]))
                        yield PyAssignStmt(PyNamedPattern(new_stream_name), value=PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'fork')))
                        yield from visit_field_inner(element, new_stream_name, target_name, c_join_accept, functools.partial(loop, i+1), True)

                yield from loop(0)
                yield from accept()

            elif isinstance(expr, MageRepeatExpr):

                if expr.min == 0 and expr.max == 1:

                    # if grammar.is_token_rule(expr.expr):
                    #     # TODO
                    #     return

                    new_stream_name = generate_name('stream')
                    yield PyAssignStmt(PyNamedPattern(target_name), value=PyNamedExpr('None'))
                    yield PyAssignStmt(PyNamedPattern(new_stream_name), value=PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'fork')))
                    temp_name = generate_name('temp')
                    def next_assign() -> Generator[PyStmt]:
                        yield PyAssignStmt(PyNamedPattern(target_name), value=PyNamedExpr(temp_name))
                        yield PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'join_to'), args=[ PyNamedExpr(new_stream_name) ]))
                    yield from visit_field_inner(expr.expr, stream_name, temp_name, next_assign, next_noop, True)
                    yield from accept()
                    return

                #elements_name = generate_field_name(prefix=f'{target_name}_elements')
                element_name = generate_name(prefix=f'{target_name}_element')

                yield PyAssignStmt(PyNamedPattern(target_name), value=PyListExpr())

                def next_min_to_max() -> Generator[PyStmt]:
                    if expr.max > expr.min:
                        if expr.max == POSINF:
                            new_stream_name = generate_name('stream')
                            def c_join() -> Generator[PyStmt]:
                                yield PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'join_to'), args=[ PyNamedExpr(new_stream_name) ]))
                            yield PyWhileStmt(
                                PyConstExpr(True),
                                [
                                    PyAssignStmt(PyNamedPattern(new_stream_name), value=PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'fork'))),
                                    *visit_field_inner(expr.expr, new_stream_name, element_name, c_join, next_break, False),
                                    PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(target_name), 'append'), args=[ PyNamedExpr(element_name) ]))
                                ]
                            )
                        else:
                            new_stream_name = generate_name('stream')
                            def c_join() -> Generator[PyStmt]:
                                yield PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'join_to'), args=[ PyNamedExpr(new_stream_name) ]))
                            yield PyForStmt(
                                PyNamedPattern('_'),
                                PyCallExpr(PyNamedExpr('range'), args=[ PyConstExpr(0), PyConstExpr(expr.min) ]),
                                body=[
                                    PyAssignStmt(PyNamedPattern(new_stream_name), value=PyCallExpr(PyAttrExpr(PyNamedExpr(stream_name), 'fork'))),
                                    *visit_field_inner(expr.expr, new_stream_name, element_name, c_join, next_break, False),
                                    PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(target_name), 'append'), args=[ PyNamedExpr(element_name) ]))
                                ]
                            )

                def gen_body():
                    def next_append() -> Generator[PyStmt]:
                        yield PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(target_name), 'append'), args=[ PyNamedExpr(element_name) ]))
                        yield from next_min_to_max()
                    yield from visit_field_inner(expr.expr, stream_name, element_name, next_append, reject, False)

                if expr.min == 0:
                    yield from next_min_to_max()

                elif expr.min == 1:
                    yield from gen_body()

                else:
                    yield PyForStmt(
                        PyNamedPattern('_'),
                        PyCallExpr(PyNamedExpr('range'), args=[ PyConstExpr(0), PyConstExpr(expr.min) ]),
                        body=list(gen_body())
                    )

                yield from accept()

            elif isinstance(expr, MageHideExpr):
                yield from visit_field_inner(expr.expr, stream_name, target_name, accept, reject, invert)

            elif isinstance(expr, MageListExpr):

                # TODO process expr.min_count

                yield PyAssignStmt(PyNamedPattern(target_name), value=PyCallExpr(PyNamedExpr('Punctuated')))

                element_name = generate_name(prefix=f'{target_name}_element')
                separator_name = generate_name(prefix=f'{target_name}_separator')

                def next_parse_separator() -> Generator[PyStmt]:
                    yield from visit_field_inner(expr.separator, stream_name, separator_name, next_append_and_continue, reject, invert)

                def next_append_and_continue() -> Generator[PyStmt]:
                    yield PyExprStmt(PyCallExpr(PyAttrExpr(PyNamedExpr(element_name), 'append'), args=[ PyNamedExpr(element_name), PyNamedExpr(separator_name) ]))

                yield PyWhileStmt(
                    PyConstExpr(True),
                    [
                        *visit_field_inner(expr.element, stream_name, element_name, next_parse_separator, next_break, invert),
                    ]
                )

                yield from accept()

            elif isinstance(expr, MageLookaheadExpr):
                if expr.is_negated:
                    yield from visit_field_inner(expr.expr, stream_name, target_name, reject, accept, invert)
                else:
                    yield from visit_field_inner(expr.expr, stream_name, target_name, accept, reject, invert)

            else:
                assert_never(expr)

        def visit_field_inner(expr: MageExpr, stream_name: str, target_name: str, accept: AcceptFn, reject: RejectFn, invert: bool) -> Generator[PyStmt]:
            if isinstance(expr, MageSeqExpr):
                n = len(expr.elements)
                indices = []
                def loop(i: int) -> Generator[PyStmt]:
                    if i == n:
                        if len(indices):
                            value = PyNamedExpr(f'{target_name}_{indices[0]}')
                        else:
                            value = PyTupleExpr(elements=list(PyNamedExpr(f'{target_name}_{i}') for i in indices))
                        yield PyAssignStmt(PyNamedPattern(target_name), value=value)
                        yield from accept()
                    else:
                        element = expr.elements[i]
                        if isinstance(element, MageHideExpr):
                            element_name = generate_name('unused')
                        else:
                            element_name = f'{target_name}_{i}'
                            indices.append(i)
                        yield from visit_field_inner(element, stream_name, element_name, functools.partial(loop, i+1), reject, invert)
                yield from loop(0)
            else:
                yield from visit_prim_field_inner(expr, stream_name, target_name, accept, reject, invert)

        def visit_toplevel(expr: MageExpr, stream_name: str, accept: AcceptFn, reject: RejectFn) -> Generator[PyStmt]:

            if isinstance(expr, MageSeqExpr):
                n = len(expr.elements)
                def loop(i: int) -> Generator[PyStmt]:
                    if i < n:
                        element = expr.elements[i]
                        if isinstance(element, MageSeqExpr):
                            yield from visit_toplevel(element, stream_name, accept, reject)
                            return
                        field_name = get_field_name(element)
                        assert(field_name is not None) # FIXME generate a field name instead
                        fields.append(field_name)
                        yield from visit_field_inner(element, stream_name, field_name, functools.partial(loop, i+1), reject, False)
                yield from loop(0)
                yield from accept()

            else:
                field_name = get_field_name(expr)
                assert(field_name is not None) # FIXME generate a field name instead
                fields.append(field_name)
                yield from visit_prim_field_inner(expr, stream_name, field_name, accept, reject, False)

        if grammar.is_variant_rule(rule):
            def c_return_result() -> Generator[PyStmt]:
                yield PyRetStmt(expr=PyNamedExpr('result'))
            return list(visit_field_inner(nonnull(rule.expr), 'stream', 'result', c_return_result, next_return_error, False))

        def c_return_struct() -> Generator[PyStmt]:
            yield PyRetStmt(
                expr=PyCallExpr(
                    PyNamedExpr(to_py_class_name(rule.name, prefix=prefix)),
                    args=list(PyKeywordArg(name, PyNamedExpr(name)) for name in fields)
                )
            )

        return list(visit_toplevel(nonnull(rule.expr), 'stream', c_return_struct, next_return_error))

    parser_body = []

    for element in grammar.elements:
        if grammar.is_parse_rule(element):
            parser_body.append(PyFuncDef(
                name=f'parse_{element.name}',
                params=[ PyNamedParam(PyNamedPattern('self')), PyNamedParam(PyNamedPattern('stream'), annotation=PyNamedExpr('ParseStream')) ],
                return_type=make_py_union([
                    PyNamedExpr(to_py_class_name(element.name, prefix=prefix)),
                    PyNamedExpr('None'),
                ]),
                body=gen_parse_body(element)
            ))

    stmts.append(PyClassDef(
        name=to_py_class_name('parser', prefix),
        bases=[ PyClassBaseArg('BaseParser') ],
        body=parser_body,
    ))

    return PyModule(stmts=stmts)
